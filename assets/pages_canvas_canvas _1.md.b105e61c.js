import{h as r,w as h,p as y,o as D,c as g,z as e,a3 as p,a4 as d,O as u}from"./chunks/framework.dda4b555.js";const x=u('<h1 id="canvas-图形基础" tabindex="-1">Canvas 图形基础 <a class="header-anchor" href="#canvas-图形基础" aria-label="Permalink to &quot;Canvas 图形基础&quot;">​</a></h1><h2 id="栅格" tabindex="-1">栅格 <a class="header-anchor" href="#栅格" aria-label="Permalink to &quot;栅格&quot;">​</a></h2><p>canvas 元素创建了一个二位坐标空间，类似于: <img src="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes/canvas_default_grid.png" alt="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes"></p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>如果图像是扭曲的，尝试使用<code>width</code>和<code>height</code>属性来设置宽高，而不是使用 CSS</p></div><h2 id="绘制矩形" tabindex="-1">绘制矩形 <a class="header-anchor" href="#绘制矩形" aria-label="Permalink to &quot;绘制矩形&quot;">​</a></h2><ol><li><code>fillRect(x, y, width, height)</code> 绘制一个填充的矩形</li><li><code>strokeRect(x, y, width, height)</code> 绘制一个矩形的边框</li><li><code>clearRect(x, y, widht, height)</code> 清楚指定矩形区域，让清楚部分完全透明</li><li><code>rect(x, y, width, height)</code> 通过矩形路径来绘制矩形，当该方法执行的时候，moveTo() 方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标。</li></ol><h2 id="绘制路径" tabindex="-1">绘制路径 <a class="header-anchor" href="#绘制路径" aria-label="Permalink to &quot;绘制路径&quot;">​</a></h2><ol><li><code>beginPath()</code> 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径</li><li><code>closePath()</code> 闭合路径之后图形绘制命令又重新指向到上下文中</li><li><code>stroke()</code> 通过线条来绘制图形轮廓</li><li><code>fill()</code> 通过填充路径的内容区域生成实心的图形</li></ol><h3 id="移动笔触" tabindex="-1">移动笔触 <a class="header-anchor" href="#移动笔触" aria-label="Permalink to &quot;移动笔触&quot;">​</a></h3><p><code>moveTo(x, y)</code> 将笔触移动到指定的坐标 x, y 上，一般使用<code>beginPath()</code>初始化之后会使用该函数设置笔触的起点</p><h3 id="线" tabindex="-1">线 <a class="header-anchor" href="#线" aria-label="Permalink to &quot;线&quot;">​</a></h3><p>绘制直线，需要用到的方法。</p><p><code>lineTo(x, y)</code> 绘制一条从笔触当前位置到指定 x, y 的位置的直线</p><h3 id="圆弧" tabindex="-1">圆弧 <a class="header-anchor" href="#圆弧" aria-label="Permalink to &quot;圆弧&quot;">​</a></h3><ol><li><p><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code> 以(x, y)为圆心，以 radius 为半径的圆弧，从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向(默认顺时针)生成</p></li><li><p><code>arcTo(x1, y1, x2, y2, radius)</code> 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点</p></li></ol><div class="tip custom-block"><p class="custom-block-title">备注</p><p><code>arcTo()</code>这个方法的实现并不是那么可靠。 <code>arc()</code>函数中需要弧度。js 中弧度的表达式: <strong>弧度=(Math.PI/180)*角度</strong></p></div><h2 id="二次贝塞尔曲线及三次贝塞尔曲线" tabindex="-1">二次贝塞尔曲线及三次贝塞尔曲线 <a class="header-anchor" href="#二次贝塞尔曲线及三次贝塞尔曲线" aria-label="Permalink to &quot;二次贝塞尔曲线及三次贝塞尔曲线&quot;">​</a></h2><ol><li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code> 绘制二次贝塞尔曲线，<code>cp1x, cp1y</code>为一个控制点, <code>x, y</code>为一个控制点</li></ol><p><strong>示例</strong></p>',19),v=e("p",null,"画布大小为300 * 300。",-1),C=e("p",null,"下面为一个二次贝塞尔曲线，通过改变`quadraticCurveTo`的变量来查看结果。",-1),b={class:"flex flex-wrap space-x-4"},_={class:"mb-4"},F=e("label",{for:"cp1x"},"cp1x：",-1),f={class:"mb-4"},m=e("label",{for:"cp1x"},"cp1y：",-1),A={class:"mb-4"},q=e("label",{for:"cp1x"},"x：",-1),k={class:"mb-4"},S=e("label",{for:"cp1x"},"y：",-1),T=u(`<ol start="2"><li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code> 绘制三次贝塞尔曲线，<code>cp1x, cp1y</code>为第一个控制点，<code>cp2x, cp2y</code>为第二个控制点，<code>x, y</code>为结束点</li></ol><h1 id="使用样式和颜色" tabindex="-1">使用样式和颜色 <a class="header-anchor" href="#使用样式和颜色" aria-label="Permalink to &quot;使用样式和颜色&quot;">​</a></h1><h2 id="色彩-colors" tabindex="-1">色彩 Colors <a class="header-anchor" href="#色彩-colors" aria-label="Permalink to &quot;色彩 Colors&quot;">​</a></h2><ol><li><code>fillStyle = color</code> 设置图形的填充颜色</li><li><code>strokeStyle = color</code> 设置图形轮廓的颜色</li></ol><div class="info custom-block"><p class="custom-block-title">备注</p><p><code>color</code> 可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象。 一旦设置了这两个值之后就是新图案的默认值，如果需要不同的颜色时需要重新设置这两个的值</p></div><p>CCS3 的合法值:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 这些 fillStyle 的值均为 &#39;橙色&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">fillStyle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">orange</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">fillStyle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#FFA500</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">fillStyle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rgb(255,165,0)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">fillStyle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rgba(255,165,0,1)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="透明度-transparency" tabindex="-1">透明度 Transparency <a class="header-anchor" href="#透明度-transparency" aria-label="Permalink to &quot;透明度 Transparency&quot;">​</a></h2><ol><li><code>globalAlpha = transparencyValue</code> 这个时全局属性，将影响 canvas 里所有图形的透明度，有效值范围 0.0 - 1.0，如果需要大量拥有相同透明度的图形时这个属性相当高效。不过只使用<code>strokeStyle</code> 和 <code>fillStyle</code> 属性接受 CSS3 的透明颜色值也是可以的</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 指定透明颜色，用于描边和填充样式</span></span>
<span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">strokeStyle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rgba(255,0,0,0.5)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">fillStyle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rgba(255,0,0,0.5)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="线型-line-styles" tabindex="-1">线型 Line Styles <a class="header-anchor" href="#线型-line-styles" aria-label="Permalink to &quot;线型 Line Styles&quot;">​</a></h2><ol><li><code>lineWidth = value</code> 设置线条宽度 - <code>1 2 3</code></li><li><code>lineCap = type</code> 设置线条末端样式 - <code>butt round square 默认butt</code></li><li><code>lineJoin = type</code> 设置线条之间结合处的样式 - <code>round bevel miter 默认miter</code></li><li><code>miterLimit = value</code> 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li><li><code>getLineDash()</code> 返回一个包含当前虚线样式，长度为非负偶数的数组。</li><li><code>setLineDash(segments)</code> 设置当前虚线样式</li><li><code>lineDashOffset = value</code> 设置虚线样式的起始偏移量</li></ol><h2 id="渐变-gradients" tabindex="-1">渐变 Gradients <a class="header-anchor" href="#渐变-gradients" aria-label="Permalink to &quot;渐变 Gradients&quot;">​</a></h2>`,13),V=JSON.parse('{"title":"canvas 学习","description":"","frontmatter":{"title":"canvas 学习"},"headers":[],"relativePath":"pages/canvas/canvas _1.md"}'),P={name:"pages/canvas/canvas _1.md"},I=Object.assign(P,{setup(w){const s=r(null),n=r(100),t=r(20),c=r(200),i=r(70);return h([n,t,c,i],()=>{const a=s.value.getContext("2d");a&&(s.value.width=300,s.value.height=300,a.beginPath(),a.moveTo(50,80),a.quadraticCurveTo(n.value,t.value,c.value,i.value),a.lineWidth=5,a.strokeStyle="red",a.stroke())}),y(()=>{const a=s.value.getContext("2d");a&&(a.beginPath(),a.moveTo(50,80),a.quadraticCurveTo(n.value,t.value,c.value,i.value),a.lineWidth=5,a.strokeStyle="red",a.stroke())}),(a,o)=>(D(),g("div",null,[x,e("div",null,[v,C,e("div",b,[e("div",_,[F,p(e("input",{id:"cp1x",type:"text","onUpdate:modelValue":o[0]||(o[0]=l=>n.value=l),class:"inline-block ring-1 w-[80px] ring-green-400 rounded-md px-2 py-1 focus:outline-none focus:border-green-500 focus:ring-green-500 focus:ring-2"},null,512),[[d,n.value]])]),e("div",f,[m,p(e("input",{id:"cp1x",type:"text","onUpdate:modelValue":o[1]||(o[1]=l=>t.value=l),class:"inline-block ring-1 w-[80px] ring-green-400 rounded-md px-2 py-1 focus:outline-none focus:border-green-500 focus:ring-green-500 focus:ring-2"},null,512),[[d,t.value]])]),e("div",A,[q,p(e("input",{id:"cp1x",type:"text","onUpdate:modelValue":o[2]||(o[2]=l=>c.value=l),class:"inline-block ring-1 w-[80px] ring-green-400 rounded-md px-2 py-1 focus:outline-none focus:border-green-500 focus:ring-green-500 focus:ring-2"},null,512),[[d,c.value]])]),e("div",k,[S,p(e("input",{id:"cp1x",type:"text","onUpdate:modelValue":o[3]||(o[3]=l=>i.value=l),class:"inline-block ring-1 w-[80px] ring-green-400 rounded-md px-2 py-1 focus:outline-none focus:border-green-500 focus:ring-green-500 focus:ring-2"},null,512),[[d,i.value]])])]),e("canvas",{ref_key:"cl1",ref:s,width:"300",height:"300",class:"border"},null,512)]),T]))}});export{V as __pageData,I as default};
